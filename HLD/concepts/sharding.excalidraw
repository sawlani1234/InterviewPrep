{
  "type": "excalidraw",
  "version": 2,
  "source": "https://excalidraw.com",
  "elements": [
    {
      "id": "W87XvNMsA84QWk0Tigx58",
      "type": "text",
      "x": 20821.534327130044,
      "y": 22701.33714804497,
      "width": 106.87992858886719,
      "height": 75,
      "angle": 0,
      "strokeColor": "#1971c2",
      "backgroundColor": "transparent",
      "fillStyle": "solid",
      "strokeWidth": 1,
      "strokeStyle": "solid",
      "roughness": 0,
      "opacity": 100,
      "groupIds": [],
      "frameId": null,
      "index": "b0j",
      "roundness": null,
      "seed": 7052077,
      "version": 12,
      "versionNonce": 543068493,
      "isDeleted": false,
      "boundElements": null,
      "updated": 1762092348709,
      "link": null,
      "locked": false,
      "text": "SHARDING\n\n",
      "fontSize": 20,
      "fontFamily": 5,
      "textAlign": "left",
      "verticalAlign": "top",
      "containerId": null,
      "originalText": "SHARDING\n\n",
      "autoResize": true,
      "lineHeight": 1.25
    },
    {
      "id": "KejUBMPJ37Y7D2iIgsrE3",
      "type": "text",
      "x": 20639.307273213286,
      "y": 22772.641570173,
      "width": 984.1793823242188,
      "height": 1950,
      "angle": 0,
      "strokeColor": "#1971c2",
      "backgroundColor": "transparent",
      "fillStyle": "solid",
      "strokeWidth": 1,
      "strokeStyle": "solid",
      "roughness": 0,
      "opacity": 100,
      "groupIds": [],
      "frameId": null,
      "index": "b0l",
      "roundness": null,
      "seed": 774890691,
      "version": 3323,
      "versionNonce": 562989347,
      "isDeleted": false,
      "boundElements": null,
      "updated": 1762093744921,
      "link": null,
      "locked": false,
      "text": "Paritioning - Divide the rows based on column in a single database instance \nSharding - Divide the data  across different instances\n           \n  Two types of Sharding \n\n  1.  Horizontal Sharding - Divide the data by rows with same columns. . This is mostly used\n  2. Vertical Sharding.  - divide the data by columns with same rows \n  \n\nChoosing shard key \n\n1. High Cardinality \n2. Support main use case query pattern \n3. Evenly distribute across shards\n\n\nSharding strategies\n\n1. Range based sharding \n2. Consistent Hash based sharding \n3. Directory based sharding - not used mostly has SPOF because of index table and has \nhigh latency \n\n\nChallenges of Sharding \n\n1. Hot spots - celeberity problem eg Taylor swift in one shard \n\n   how to prevent \n   a. distribute through composite shard like user_id + created_at or something\n   b. move hot keys to dedicated shards \n   c. Dynamic shard splitting. (provided by some database like DynamoDB)\n\n2. Cross shard operations \n  \n    a. Ideally we should avoid cross shard operations by having shard based on ur main\n  query access pattern \n    b. if occasional cross shard operation are required for read then fine \n    c. for frequent usage can cache the results as most system is eventual cosnsitent\n    d. for read can denormalise the data although it adds complexity of data writing \n  \n3. Maintaining consistency\n    a. for cross shard write again should be avoided to solve it is saga pattern , have compensating \n      operation for each step , eg transferring money from user a wallet to user b , both users \n     in different shards \n    b. if eventual consistency is acceptable then fine \n    c. strive to have shards as per access pattern \n\n\n Sharding in system design interview\n\nWhen to go for sharding ? Mostly follow numbers to know \n\n1. Storage - If database reaches 25 TB capactiy \n2. Write - if database has 50000 write operations per sec\n3. Read - check this again and add once get from numbers to know\n\nWhat to say ?\n\nafter determining the sharding is required \n\n1. choose shard key - which has high cardinality , even distributoin and serves\nour query pattern\n\n2. choose distribution strategy - consistent hashing strategy lets say \n\n3. call out tradeoffs - for eg global query which may require caching \n\n4. address how handle growth - new shards based on our system growth \n, lesss data movement blah blah\n\n\n\n\n\n\n\n",
      "fontSize": 20,
      "fontFamily": 5,
      "textAlign": "left",
      "verticalAlign": "top",
      "containerId": null,
      "originalText": "Paritioning - Divide the rows based on column in a single database instance \nSharding - Divide the data  across different instances\n           \n  Two types of Sharding \n\n  1.  Horizontal Sharding - Divide the data by rows with same columns. . This is mostly used\n  2. Vertical Sharding.  - divide the data by columns with same rows \n  \n\nChoosing shard key \n\n1. High Cardinality \n2. Support main use case query pattern \n3. Evenly distribute across shards\n\n\nSharding strategies\n\n1. Range based sharding \n2. Consistent Hash based sharding \n3. Directory based sharding - not used mostly has SPOF because of index table and has \nhigh latency \n\n\nChallenges of Sharding \n\n1. Hot spots - celeberity problem eg Taylor swift in one shard \n\n   how to prevent \n   a. distribute through composite shard like user_id + created_at or something\n   b. move hot keys to dedicated shards \n   c. Dynamic shard splitting. (provided by some database like DynamoDB)\n\n2. Cross shard operations \n  \n    a. Ideally we should avoid cross shard operations by having shard based on ur main\n  query access pattern \n    b. if occasional cross shard operation are required for read then fine \n    c. for frequent usage can cache the results as most system is eventual cosnsitent\n    d. for read can denormalise the data although it adds complexity of data writing \n  \n3. Maintaining consistency\n    a. for cross shard write again should be avoided to solve it is saga pattern , have compensating \n      operation for each step , eg transferring money from user a wallet to user b , both users \n     in different shards \n    b. if eventual consistency is acceptable then fine \n    c. strive to have shards as per access pattern \n\n\n Sharding in system design interview\n\nWhen to go for sharding ? Mostly follow numbers to know \n\n1. Storage - If database reaches 25 TB capactiy \n2. Write - if database has 50000 write operations per sec\n3. Read - check this again and add once get from numbers to know\n\nWhat to say ?\n\nafter determining the sharding is required \n\n1. choose shard key - which has high cardinality , even distributoin and serves\nour query pattern\n\n2. choose distribution strategy - consistent hashing strategy lets say \n\n3. call out tradeoffs - for eg global query which may require caching \n\n4. address how handle growth - new shards based on our system growth \n, lesss data movement blah blah\n\n\n\n\n\n\n\n",
      "autoResize": true,
      "lineHeight": 1.25
    }
  ],
  "appState": {
    "gridSize": 20,
    "gridStep": 5,
    "gridModeEnabled": false,
    "viewBackgroundColor": "#ffffff",
    "lockedMultiSelections": {}
  },
  "files": {}
}