{
  "type": "excalidraw",
  "version": 2,
  "source": "https://excalidraw.com",
  "elements": [
    {
      "id": "ccnnIvTAJZBNNVb8o7giB",
      "type": "text",
      "x": 16615.35591319871,
      "y": 18654.69652722706,
      "width": 267.1199035644531,
      "height": 100,
      "angle": 0,
      "strokeColor": "#1971c2",
      "backgroundColor": "transparent",
      "fillStyle": "solid",
      "strokeWidth": 1,
      "strokeStyle": "solid",
      "roughness": 0,
      "opacity": 100,
      "groupIds": [],
      "frameId": null,
      "index": "a1",
      "roundness": null,
      "seed": 48403339,
      "version": 52,
      "versionNonce": 267260139,
      "isDeleted": false,
      "boundElements": null,
      "updated": 1757770631851,
      "link": null,
      "locked": false,
      "text": "NETWORKING CONCEPTS \n\n\n",
      "fontSize": 20,
      "fontFamily": 5,
      "textAlign": "left",
      "verticalAlign": "top",
      "containerId": null,
      "originalText": "NETWORKING CONCEPTS \n\n\n",
      "autoResize": true,
      "lineHeight": 1.25
    },
    {
      "id": "P8u0SMxIDOjwPcU3SFn1t",
      "type": "text",
      "x": 16439.59074628588,
      "y": 18804.39262665805,
      "width": 1266.2789306640625,
      "height": 1975,
      "angle": 0,
      "strokeColor": "#1971c2",
      "backgroundColor": "transparent",
      "fillStyle": "solid",
      "strokeWidth": 1,
      "strokeStyle": "solid",
      "roughness": 0,
      "opacity": 100,
      "groupIds": [],
      "frameId": null,
      "index": "a2",
      "roundness": null,
      "seed": 467369195,
      "version": 6109,
      "versionNonce": 1461902373,
      "isDeleted": false,
      "boundElements": null,
      "updated": 1757772828146,
      "link": null,
      "locked": false,
      "text": "1.  We have OSI layer in the way \n    a. Physical layer \n    b. Data link layer\n    c. Network layer - Performs packet  routing based on IP\n    d. Transport layer - is of type TCP and UDP , protocols responsible of delivery of packet \n\n         i) TCP - guarantees order , reliaable deliver with flow control and congestion control . mostly \n        used for day to day APPS and services which majorily require reliable delivery \n          has 3 way handshake for initiated  - SYNC , SYNC-ACK , SYNC \n          for terminating - FIN , ACK , FIN ,ACK \n        ii). UDP - unreliable delivery , fire and forget concept , best effort delivery low latency\n\n   e. Session layer - \n   f . Presentation layer \n   g. Application layer - \n        i. HTTP/HTTPS  - hyper text transfer protocol has key value pair in headers that determine \nvarious things for eg contenty-type , keep-alive for connections time out authorization headers etc . HTTPS\nprovies encyrption in transit \n        ii. gRPC - google remote procedure call basically by default uses protobuf which is binary encodie\n         hence it is fast as compared to HTTp because of less data neeeds to be transmitted over network\n        iii. REST - an API paradigm over HTTp , the APIS are formed using \n            GET (for fetching resource)  , \n            POST(for inserting resource) , \n            PUT (for update resource)\n            PATCH (for partial update resource) , \n            DELETE (for deleting resource)\n         iv) Websockets - are on upgraded hTTP , that provides bidrectional persistent connection  \n                mostly used for chats app etc\n          v) SSE - Server sent events basicaly its a persistent connection over HTTP where server sent events in chunk\n             for eg notification , where server wants to notify APP(client) regaridgn multiple offers of food etc\n          vi) WebRTC - used for P2P connections where latency of delivery is important over reliable delivery \n                eg  video chat\n\n  2. Now we have loadbalancers , which are of two types \n\n       1. Client side load balancer - \n            Eg redis cluser - where redis client has the hash slot to node map and each node in clsuter\n             has information of other node  , so redis client directly connects to designated node \n             and if lets say there is a rebalance and we connect to wrong node , redis cluster \n            redirects to correct node and sends MOVE to cline and client update its map by quering cluster\n            \n            DNS resovler. -> sends different ordering of resolved IPS to clients which they an use \n            to call servers \n   \n             grpc - also uses client side load baalcning as it listens to service registry for updates \n\n\n     use client side load balancing \n        1. for internal microservice communication through grpc \n        2. when its okay to have delay in propogation of details of server for eg DNS based load balancing\n\n\n    Dedicated load balancer \n\n    1. for any external calls use dedicated load balancer as the clients would connect with this load balancer \n      because external client directly connecting with servers would bypass rate limiting , authentcation and all \n\n   2. They operate on two levels L4 (network layer) -> used for persistent connection (Websocket)  , they route \n        based on request IP and port\n        and L7  (Application layer for HTTP requesT), they have more intelligent routing based on complete payload \n\n    2. they occur in different forms like  software -> nginx , hardware , cloud based (most popular) - AWS NLB/ALB/ELB \n    \n    Load balancing algorithm -> round robin , random , IP hash , least connection , least latency\n\n\n  Few things for reginolisation \n    1. CDN -> Edge CDN for caching static files , delivering to users with low latency\n    2. Paritioning -> partiioning db by city or country and haveing that parition in that particular city neares region\n  \n Fault tolerance \n    1. Retries with exponential back off with jitters(which is a small random delata added to next backoff) to spread the retries \n    2. Idempotency -> essentially same request when retired from client due to some reason should not have any side effect\n\n       \n Cirucite breaker\n   1. To trip on and off the switch when a service is down , prevents thundering heard , fails fast , and recovers automatically\n        \n",
      "fontSize": 20,
      "fontFamily": 5,
      "textAlign": "left",
      "verticalAlign": "top",
      "containerId": null,
      "originalText": "1.  We have OSI layer in the way \n    a. Physical layer \n    b. Data link layer\n    c. Network layer - Performs packet  routing based on IP\n    d. Transport layer - is of type TCP and UDP , protocols responsible of delivery of packet \n\n         i) TCP - guarantees order , reliaable deliver with flow control and congestion control . mostly \n        used for day to day APPS and services which majorily require reliable delivery \n          has 3 way handshake for initiated  - SYNC , SYNC-ACK , SYNC \n          for terminating - FIN , ACK , FIN ,ACK \n        ii). UDP - unreliable delivery , fire and forget concept , best effort delivery low latency\n\n   e. Session layer - \n   f . Presentation layer \n   g. Application layer - \n        i. HTTP/HTTPS  - hyper text transfer protocol has key value pair in headers that determine \nvarious things for eg contenty-type , keep-alive for connections time out authorization headers etc . HTTPS\nprovies encyrption in transit \n        ii. gRPC - google remote procedure call basically by default uses protobuf which is binary encodie\n         hence it is fast as compared to HTTp because of less data neeeds to be transmitted over network\n        iii. REST - an API paradigm over HTTp , the APIS are formed using \n            GET (for fetching resource)  , \n            POST(for inserting resource) , \n            PUT (for update resource)\n            PATCH (for partial update resource) , \n            DELETE (for deleting resource)\n         iv) Websockets - are on upgraded hTTP , that provides bidrectional persistent connection  \n                mostly used for chats app etc\n          v) SSE - Server sent events basicaly its a persistent connection over HTTP where server sent events in chunk\n             for eg notification , where server wants to notify APP(client) regaridgn multiple offers of food etc\n          vi) WebRTC - used for P2P connections where latency of delivery is important over reliable delivery \n                eg  video chat\n\n  2. Now we have loadbalancers , which are of two types \n\n       1. Client side load balancer - \n            Eg redis cluser - where redis client has the hash slot to node map and each node in clsuter\n             has information of other node  , so redis client directly connects to designated node \n             and if lets say there is a rebalance and we connect to wrong node , redis cluster \n            redirects to correct node and sends MOVE to cline and client update its map by quering cluster\n            \n            DNS resovler. -> sends different ordering of resolved IPS to clients which they an use \n            to call servers \n   \n             grpc - also uses client side load baalcning as it listens to service registry for updates \n\n\n     use client side load balancing \n        1. for internal microservice communication through grpc \n        2. when its okay to have delay in propogation of details of server for eg DNS based load balancing\n\n\n    Dedicated load balancer \n\n    1. for any external calls use dedicated load balancer as the clients would connect with this load balancer \n      because external client directly connecting with servers would bypass rate limiting , authentcation and all \n\n   2. They operate on two levels L4 (network layer) -> used for persistent connection (Websocket)  , they route \n        based on request IP and port\n        and L7  (Application layer for HTTP requesT), they have more intelligent routing based on complete payload \n\n    2. they occur in different forms like  software -> nginx , hardware , cloud based (most popular) - AWS NLB/ALB/ELB \n    \n    Load balancing algorithm -> round robin , random , IP hash , least connection , least latency\n\n\n  Few things for reginolisation \n    1. CDN -> Edge CDN for caching static files , delivering to users with low latency\n    2. Paritioning -> partiioning db by city or country and haveing that parition in that particular city neares region\n  \n Fault tolerance \n    1. Retries with exponential back off with jitters(which is a small random delata added to next backoff) to spread the retries \n    2. Idempotency -> essentially same request when retired from client due to some reason should not have any side effect\n\n       \n Cirucite breaker\n   1. To trip on and off the switch when a service is down , prevents thundering heard , fails fast , and recovers automatically\n        \n",
      "autoResize": true,
      "lineHeight": 1.25
    }
  ],
  "appState": {
    "gridSize": 20,
    "gridStep": 5,
    "gridModeEnabled": false,
    "viewBackgroundColor": "#ffffff",
    "lockedMultiSelections": {}
  },
  "files": {}
}