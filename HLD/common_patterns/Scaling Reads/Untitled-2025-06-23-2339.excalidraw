{
  "type": "excalidraw",
  "version": 2,
  "source": "https://excalidraw.com",
  "elements": [
    {
      "id": "pZFVZR7cUh6LpmGXpnYmI",
      "type": "text",
      "x": 24656.80576512363,
      "y": 26989.861758130413,
      "width": 165.73988342285156,
      "height": 75,
      "angle": 0,
      "strokeColor": "#1971c2",
      "backgroundColor": "transparent",
      "fillStyle": "solid",
      "strokeWidth": 1,
      "strokeStyle": "solid",
      "roughness": 0,
      "opacity": 100,
      "groupIds": [],
      "frameId": null,
      "index": "b2T",
      "roundness": null,
      "seed": 719232321,
      "version": 29,
      "versionNonce": 1511506369,
      "isDeleted": false,
      "boundElements": null,
      "updated": 1762624983136,
      "link": null,
      "locked": false,
      "text": "SCALING READS\n\n",
      "fontSize": 20,
      "fontFamily": 5,
      "textAlign": "left",
      "verticalAlign": "top",
      "containerId": null,
      "originalText": "SCALING READS\n\n",
      "autoResize": true,
      "lineHeight": 1.25
    },
    {
      "id": "HUEF8jd5PoZx3dy8vUVoP",
      "type": "text",
      "x": 24556.80576512363,
      "y": 27091.861758130413,
      "width": 595.2797241210938,
      "height": 100,
      "angle": 0,
      "strokeColor": "#1971c2",
      "backgroundColor": "transparent",
      "fillStyle": "solid",
      "strokeWidth": 1,
      "strokeStyle": "solid",
      "roughness": 0,
      "opacity": 100,
      "groupIds": [],
      "frameId": null,
      "index": "b2X",
      "roundness": null,
      "seed": 137985071,
      "version": 88,
      "versionNonce": 1903328929,
      "isDeleted": false,
      "boundElements": null,
      "updated": 1762626499225,
      "link": null,
      "locked": false,
      "text": "1. Standard read to write ratio is 10:1 and can go upto 100:1\n\n\n",
      "fontSize": 20,
      "fontFamily": 5,
      "textAlign": "left",
      "verticalAlign": "top",
      "containerId": null,
      "originalText": "1. Standard read to write ratio is 10:1 and can go upto 100:1\n\n\n",
      "autoResize": true,
      "lineHeight": 1.25
    },
    {
      "id": "1g_KGOJhCugU8zewR9az0",
      "type": "text",
      "x": 24540.80576512363,
      "y": 27169.314883130413,
      "width": 987.5792846679688,
      "height": 1625,
      "angle": 0,
      "strokeColor": "#1971c2",
      "backgroundColor": "transparent",
      "fillStyle": "solid",
      "strokeWidth": 1,
      "strokeStyle": "solid",
      "roughness": 0,
      "opacity": 100,
      "groupIds": [],
      "frameId": null,
      "index": "b2Y",
      "roundness": null,
      "seed": 885990031,
      "version": 2275,
      "versionNonce": 703721345,
      "isDeleted": false,
      "boundElements": null,
      "updated": 1762679460842,
      "link": null,
      "locked": false,
      "text": "Solution \n\nData modelling\n\nDenormialization\n1. Optimise queries by modeling the data turn into denormalised form \nmakes the read fast by avoiding join but can increase latency writes \ndo this if writes are not that high primarily if a system is more read dominant\n\nIndexing \n1. Do indexing to fasten your search by O(logn) for attribute which u are filtering , joining sorting - \n        a. Search with query\n        b. page search can lead to O(logN)\n        c. then row position on that page\n\nHardware upgrade\n\nSimple hardware upgrade can serve more traffic due to more CPU , MEMORY (ram) and more IOPS\n\n\nScaling \n\n1. Read replica addition \n2. Sharding - mostly happens with write scaling\n\nCaching \n1. Cache before database\n   Invalidation strategies\n   a . TTL \n   b.  Write through invalidation once data updates\n   c. version based blah blah\n   d, Ur ttl should be mostly around ur NFR, i.e. user data consistency for 30 sec\n\n\nCDN\n 1. Caching data in CDN nodes, can lead to low latency for a region \n 2. Usually used for static data cachinng , although can be used for dynamic as well now\n 3. CDN caching should be global things like global post , images not user specific\n\n\n\nCommon Deep dives \n\n1. What happens when your queries start taking longer as your dataset grows?\n  - same query timeouts \n  - proper indexing  (B-tree)\n \n2. How do you handle millions of concurrent reads for the same cached data?\n  - hot key problem \n  - do request collocaesing\n  - better use partitioning of key into multiple shards for fair distribution of load\n\n3. What happens when multiple requests try to rebuild an expired cache entry simultaneously?\n   - this mostly happens if rebuild is high remember FS\n   - use prabaalistic early update\n   - for more cirtical data just use exact job schedule less than that of TTL of cache \n\n\n4 . Cache invalidtion how , if entry has to be seen immediately. ?\n\n   - use write through cache invalidation\n   - user versioning but it does not seem to well in hello interview article so sit with first \n   - \n\n",
      "fontSize": 20,
      "fontFamily": 5,
      "textAlign": "left",
      "verticalAlign": "top",
      "containerId": null,
      "originalText": "Solution \n\nData modelling\n\nDenormialization\n1. Optimise queries by modeling the data turn into denormalised form \nmakes the read fast by avoiding join but can increase latency writes \ndo this if writes are not that high primarily if a system is more read dominant\n\nIndexing \n1. Do indexing to fasten your search by O(logn) for attribute which u are filtering , joining sorting - \n        a. Search with query\n        b. page search can lead to O(logN)\n        c. then row position on that page\n\nHardware upgrade\n\nSimple hardware upgrade can serve more traffic due to more CPU , MEMORY (ram) and more IOPS\n\n\nScaling \n\n1. Read replica addition \n2. Sharding - mostly happens with write scaling\n\nCaching \n1. Cache before database\n   Invalidation strategies\n   a . TTL \n   b.  Write through invalidation once data updates\n   c. version based blah blah\n   d, Ur ttl should be mostly around ur NFR, i.e. user data consistency for 30 sec\n\n\nCDN\n 1. Caching data in CDN nodes, can lead to low latency for a region \n 2. Usually used for static data cachinng , although can be used for dynamic as well now\n 3. CDN caching should be global things like global post , images not user specific\n\n\n\nCommon Deep dives \n\n1. What happens when your queries start taking longer as your dataset grows?\n  - same query timeouts \n  - proper indexing  (B-tree)\n \n2. How do you handle millions of concurrent reads for the same cached data?\n  - hot key problem \n  - do request collocaesing\n  - better use partitioning of key into multiple shards for fair distribution of load\n\n3. What happens when multiple requests try to rebuild an expired cache entry simultaneously?\n   - this mostly happens if rebuild is high remember FS\n   - use prabaalistic early update\n   - for more cirtical data just use exact job schedule less than that of TTL of cache \n\n\n4 . Cache invalidtion how , if entry has to be seen immediately. ?\n\n   - use write through cache invalidation\n   - user versioning but it does not seem to well in hello interview article so sit with first \n   - \n\n",
      "autoResize": true,
      "lineHeight": 1.25
    }
  ],
  "appState": {
    "gridSize": 20,
    "gridStep": 5,
    "gridModeEnabled": false,
    "viewBackgroundColor": "#ffffff",
    "lockedMultiSelections": {}
  },
  "files": {}
}